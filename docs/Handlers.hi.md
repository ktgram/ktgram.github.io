---
---
title: हैंडलर
---


### हैंडलर की विविधता

बॉट विकास में, विशेष रूप से उपयोगकर्ता इंटरैक्शन में शामिल सिस्टम में, कमांड और इवेंट को कुशलतापूर्वक प्रबंधित और संसाधित करना महत्वपूर्ण है।

ये एनोटेशन विशिष्ट कमांड, इनपुट या अपडेट को संसाधित करने के लिए डिज़ाइन की गई फ़ंक्शंस को चिह्नित करते हैं और कमांड कीवर्ड, स्कोप और गार्ड जैसे मेटाडेटा प्रदान करते हैं।

### एनोटेशन अवलोकन

#### CommandHandler

`CommandHandler` एनोटेशन विशिष्ट कमांड को संसाधित करने वाली फ़ंक्शंस को चिह्नित करने के लिए उपयोग किया जाता है। यह एनोटेशन कमांड के कीवर्ड और स्कोप को परिभाषित करने वाले गुणों को शामिल करता है।

-   **value**: कमांड से संबंधित कीवर्ड निर्दिष्ट करता है।
-   **scope**: वह संदर्भ या स्कोप निर्धारित करता है जिसमें कमांड की जाँच की जाएगी।

```kotlin
@CommandHandler(["text"])
suspend fun test(user: User, bot: TelegramBot) {
    //...
}
```

##### CommandHandler.CallbackQuery

`CommandHandler` एनोटेशन का एक विशेषीकृत संस्करण जो विशेष रूप से कॉलबैक क्वेरी को संभालने के लिए डिज़ाइन किया गया है। इसमें `CommandHandler` के समान गुण शामिल हैं, जो कॉलबैक से संबंधित कमांड पर ध्यान केंद्रित करते हैं।

_यह वास्तव में बस `@CommandHandler` के समान है जिसमें पूर्वनिर्धारित `UpdateType.CALLBACK_QUERY` स्कोप है_।

-   **value**: कमांड से संबंधित कीवर्ड निर्दिष्ट करता है।
-   **autoAnswer**: `callbackQuery` का स्वचालित रूप से उत्तर दें (संभालने से पहले `answerCallbackQuery` कॉल करें)।

```kotlin
@CommandHandler.CallbackQuery(["text"])
suspend fun test(user: User, bot: TelegramBot) {
    //...
}
```

#### CommonHandler

`CommonHandler` एनोटेशन `CommandHandler` और `InputHandler` की तुलना में कम प्राथमिकता वाले कमांड को संसाधित करने वाली फ़ंक्शंस के लिए अभिप्रेत है। इसका उपयोग स्रोत स्तर पर किया जाता है और सामान्य कमांड हैंडलर को परिभाषित करने का एक लचीला तरीका प्रदान करता है।

**ध्यान दें, प्राथमिकता केवल `@CommonHandler` के भीतर ही काम करती है (अर्थात अन्य हैंडलर को प्रभावित नहीं करती)।**

##### CommonHandler.Text

यह एनोटेशन अपडेट के खिलाफ पाठ मिलान को निर्दिष्ट करता है। इसमें मिलान पाठ, फ़िल्टरिंग स्थितियाँ, प्राथमिकता और स्कोप को परिभाषित करने के लिए गुण शामिल हैं।

-   **value**: आने वाले अपडेट के खिलाफ मिलान करने के लिए पाठ।
-   **filter**: मिलान प्रक्रिया में उपयोग की जाने वाली स्थितियों को परिभाषित करने वाली कक्षा।
-   **priority**: हैंडलर का प्राथमिकता स्तर, जहाँ 0 सबसे उच्च प्राथमिकता है।
-   **scope**: वह संदर्भ या स्कोप जिसमें पाठ मिलान की जाँच की जाएगी।

```kotlin
@CommonHandler.Text(["text"], filter = isNewUserFilter::class, priority = 10)
suspend fun test(user: User, bot: TelegramBot) {
    //...
}
```

##### CommonHandler.Regex

`CommonHandler.Text` के समान, यह एनोटेशन नियमित अभिव्यक्तियों के आधार पर अपडेट से मिलान करने के लिए उपयोग किया जाता है। इसमें रेगेक्स पैटर्न, विकल्प, फ़िल्टरिंग स्थितियाँ, प्राथमिकता और स्कोप को परिभाषित करने के लिए गुण शामिल हैं।

-   **value**: मिलान के लिए उपयोग किया जाने वाला रेगेक्स पैटर्न।
-   **options**: रेगेक्स पैटर्न के व्यवहार को संशोधित करने वाले रेगेक्स विकल्प।
-   **filter**: मिलान प्रक्रिया में उपयोग की जाने वाली स्थितियों को परिभाषित करने वाली कक्षा।
-   **priority**: हैंडलर का प्राथमिकता स्तर, जहाँ 0 सबसे उच्च प्राथमिकता है।
-   **scope**: वह संदर्भ या स्कोप जिसमें रेगेक्स मिलान की जाँच की जाएगी।

```kotlin
@CommonHandler.Regex("^\d+$", scope = [UpdateType.EDITED_MESSAGE])
suspend fun test(update: EditedMessageUpdate, user: User, bot: TelegramBot) {
    //...
}
```

#### InputHandler

`InputHandler` एनोटेशन विशिष्ट इनपुट इवेंट को संसाधित करने वाली फ़ंक्शंस को चिह्नित करता है। इसका उपयोग रनटाइम पर इनपुट को संभालने वाली फ़ंक्शंस के लिए अभिप्रेत है और इनपुट कीवर्ड और स्कोप को परिभाषित करने के लिए गुण शामिल हैं।

-   **value**: इनपुट इवेंट से संबंधित कीवर्ड निर्दिष्ट करता है।

```kotlin
@InputHandler("text")
suspend fun test(update: ProcessedUpdate, user: User, bot: TelegramBot) {
    //...
}
```

#### UnprocessedHandler

`UnprocessedHandler` एनोटेशन अन्य हैंडलर द्वारा संसाधित नहीं किए गए अपडेट को संभालने वाली फ़ंक्शंस को चिह्नित करने के लिए उपयोग किया जाता है। यह सुनिश्चित करता है कि कोई भी असंसाधित अपडेट उचित रूप से प्रबंधित किए जाएं, इस हैंडलर प्रकार के लिए केवल एक प्रसंस्करण बिंदु संभव है।

```kotlin
@UnprocessedHandler
suspend fun test(update: ProcessedUpdate, user: User, bot: TelegramBot) {
    //...
}
```

#### UpdateHandler

`UpdateHandler` एनोटेशन विशिष्ट प्रकार के आने वाले अपडेट को संभालने वाली फ़ंक्शंस को चिह्नित करता है। यह विभिन्न अपडेट प्रकारों को व्यवस्थित रूप से वर्गीकृत और संसाधित करने का एक तरीका प्रदान करता है।

-   **type**: वह अपडेट प्रकार निर्दिष्ट करता है जिसे हैंडलर फ़ंक्शन संसाधित करेगा।

```kotlin
@UpdateHandler([UpdateType.PRE_CHECKOUT_QUERY])
suspend fun test(update: PreCheckoutQueryUpdate, user: User, bot: TelegramBot) {
    //...
}
```
### हैंडलर साथी एनोटेशन

ऐसे अतिरिक्त एनोटेशन भी हैं जो हैंडलर के लिए वैकल्पिक हैं, जो हैंडलर के वैकल्पिक व्यवहार को पूरक करते हैं।

उन्हें उस फ़ंक्शन पर रखा जा सकता है जिस पर हैंडलर लागू किया गया है और कक्षाओं पर, बाद वाले मामले में वे उस कक्षा में सभी हैंडलर पर स्वचालित रूप से लागू होंगे, लेकिन यदि आवश्यकता हो तो कुछ फ़ंक्शंस के लिए अलग व्यवहार होना संभव है।

अर्थात, आवेदन की ऐसी प्राथमिकता है, `Function` > `Class`, जहाँ फ़ंक्शन की उच्च प्राथमिकता है।

#### दर सीमित करना

इसके अलावा, आइए एनोटेशन में वर्णित दर सीमित करने की तंत्र को भी प्रकट करें।

आप प्रत्येक उपयोगकर्ता के लिए सामान्य सीमाएँ निर्धारित कर सकते हैं:

```kotlin
// ...
val bot = TelegramBot("BOT_TOKEN") {
    rateLimiter { // सामान्य सीमाएँ
        limits = RateLimits(period = 10000, rate = 5)
    }
}
```

###### हैंडलर विशिष्ट

`RateLimits` एनोटेशन का उपयोग करके कुछ क्रियाओं पर सीमाएँ परिभाषित की जा सकती हैं, जो `@CommandHandler`, `@CommandHandler.CallbackQuery`, `@InputHandler`, `@CommonHandler` का समर्थन करता है।

```kotlin
@CommandHandler(["/start"])
@RateLimits(period = 1000L, rate = 1L)
suspend fun start(user: User, bot: TelegramBot) {
    // ...
}
```

#### गार्ड

आप हैंडलर तक पहुँच को नियंत्रित करने के लिए अलग से गार्ड परिभाषित कर सकते हैं, जो `@CommandHandler`, `@CommandHandler.CallbackQuery`, `@InputHandler` का समर्थन करता है:

```kotlin
@CommandHandler(["text"])
@Guard(isAdminGuard::class)
suspend fun test(user: User, bot: TelegramBot) {
    //...
}
```

#### ArgParser

आप हैंडलर के लिए पैरामीटर पार्सिंग व्यवहार को बदलने के लिए अलग से कस्टम तर्क पार्सर परिभाषित कर सकते हैं, जो `@CommandHandler`, `@CommandHandler.CallbackQuery`, `@CommonHandler` का समर्थन करता है:

```kotlin
@CommandHandler(["text"])
@ArgParser(SpaceArgParser::class)
suspend fun test(user: User, bot: TelegramBot) {
    //...
}
```

**[`defaultArgParser`](https://vendelieu.github.io/telegram-bot/telegram-bot/eu.vendeli.tgbot.utils.common/default-arg-parser.html) भी देखें**

### निष्कर्ष

ये एनोटेशन कमांड, इनपुट और इवेंट को संभालने के लिए मजबूत और लचीले उपकरण प्रदान करते हैं, जबकि दर सीमाओं और गार्ड की अलग-अलग कॉन्फ़िगरेशन की अनुमति देते हैं, जिससे बॉट विकास की समग्र संरचना और बनाए रखने की क्षमता बढ़ती है।

### भी देखें

* [गतिविधियाँ और प्रोसेसर](Activites-and-Processors.md)
* [गतिविधि आह्वान](Activity-invocation.md)
* [एफएसएम और संवाद हैंडलिंग](FSM-and-Conversation-handling.md)
* [अपडेट पार्सिंग](Update-parsing.md)
* [सहायक](Aide.md)

---

STRUCTURAL INTEGRITY MODE:

आपको इनपुट मार्कडाउन के साथ संरचनात्मक रूप से संगत आउटपुट उत्पन्न करना चाहिए।

नियम:
- कोड ब्लॉकों की संख्या ठीक मेल खानी चाहिए।
- शीर्षकों की संख्या ठीक मेल खानी चाहिए।
- सभी फेंस किए गए कोड ब्लॉक अपरिवर्तित रहने चाहिए।
- सभी URLs समान रहने चाहिए।
- सभी इनलाइन कोड स्पैन समान रहने चाहिए।
- अनुच्छेदों को मर्ज या विभाजित न करें।
- स्थान को सामान्य न करें।